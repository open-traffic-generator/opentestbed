/* Open Traffic Generator Testbed Model API 0.0.4
 * OTG Testbed Model
 * License: MIT */

package goopentestbed

import (
	"bytes"
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"strings"

	"github.com/ghodss/yaml"
	opentestbed "github.com/open-traffic-generator/opentestbed/goopentestbed/opentestbed"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/emptypb"
)

// function related to error handling
func FromError(err error) (Error, bool) {
	if rErr, ok := err.(Error); ok {
		return rErr, true
	}

	rErr := NewError()
	if err := rErr.Unmarshal().FromJson(err.Error()); err == nil {
		return rErr, true
	}

	return fromGrpcError(err)
}

func setResponseErr(obj Error, code int32, message string) {
	errors := []string{}
	errors = append(errors, message)
	obj.msg().Code = &code
	obj.msg().Errors = errors
}

// parses and return errors for grpc response
func fromGrpcError(err error) (Error, bool) {
	st, ok := status.FromError(err)
	if ok {
		rErr := NewError()
		if err := rErr.Unmarshal().FromJson(st.Message()); err == nil {
			var code = int32(st.Code())
			rErr.msg().Code = &code
			return rErr, true
		}

		setResponseErr(rErr, int32(st.Code()), st.Message())
		return rErr, true
	}

	return nil, false
}

// parses and return errors for http responses
func fromHttpError(statusCode int, body []byte) Error {
	rErr := NewError()
	bStr := string(body)
	if err := rErr.Unmarshal().FromJson(bStr); err == nil {
		return rErr
	}

	setResponseErr(rErr, int32(statusCode), bStr)

	return rErr
}

type versionMeta struct {
	checkVersion  bool
	localVersion  Version
	remoteVersion Version
	checkError    error
}
type goopentestbedApi struct {
	apiSt
	grpcClient  opentestbed.OpenapiClient
	httpClient  httpClient
	versionMeta *versionMeta
}

// grpcConnect builds up a grpc connection
func (api *goopentestbedApi) grpcConnect() error {
	if api.grpcClient == nil {
		if api.grpc.clientConnection == nil {
			ctx, cancelFunc := context.WithTimeout(context.Background(), api.grpc.dialTimeout)
			defer cancelFunc()
			conn, err := grpc.DialContext(ctx, api.grpc.location, grpc.WithTransportCredentials(insecure.NewCredentials()))
			if err != nil {
				return err
			}
			api.grpcClient = opentestbed.NewOpenapiClient(conn)
			api.grpc.clientConnection = conn
		} else {
			api.grpcClient = opentestbed.NewOpenapiClient(api.grpc.clientConnection)
		}
	}
	return nil
}

func (api *goopentestbedApi) grpcClose() error {
	if api.grpc != nil {
		if api.grpc.clientConnection != nil {
			err := api.grpc.clientConnection.Close()
			if err != nil {
				return err
			}
		}
	}
	api.grpcClient = nil
	api.grpc = nil
	return nil
}

func (api *goopentestbedApi) Close() error {
	if api.hasGrpcTransport() {
		err := api.grpcClose()
		return err
	}
	if api.hasHttpTransport() {
		err := api.http.conn.(*net.TCPConn).SetLinger(0)
		api.http.conn.Close()
		api.http.conn = nil
		api.http = nil
		api.httpClient.client = nil
		return err
	}
	return nil
}

// NewApi returns a new instance of the top level interface hierarchy
func NewApi() Api {
	api := goopentestbedApi{}
	api.versionMeta = &versionMeta{checkVersion: false}
	return &api
}

// httpConnect builds up a http connection
func (api *goopentestbedApi) httpConnect() error {
	if api.httpClient.client == nil {
		tr := http.Transport{
			DialTLSContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
				tcpConn, err := (&net.Dialer{}).DialContext(ctx, network, addr)
				if err != nil {
					return nil, err
				}
				tlsConn := tls.Client(tcpConn, &tls.Config{InsecureSkipVerify: !api.http.verify})
				err = tlsConn.Handshake()
				if err != nil {
					return nil, err
				}
				api.http.conn = tcpConn
				return tlsConn, nil
			},
			DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
				tcpConn, err := (&net.Dialer{}).DialContext(ctx, network, addr)
				if err != nil {
					return nil, err
				}
				api.http.conn = tcpConn
				return tcpConn, nil
			},
		}
		client := httpClient{
			client: &http.Client{
				Transport: &tr,
			},
			ctx: context.Background(),
		}
		api.httpClient = client
	}
	return nil
}

func (api *goopentestbedApi) httpSendRecv(urlPath string, jsonBody string, method string) (*http.Response, error) {
	err := api.httpConnect()
	if err != nil {
		return nil, err
	}
	httpClient := api.httpClient
	var bodyReader = bytes.NewReader([]byte(jsonBody))
	queryUrl, err := url.Parse(api.http.location)
	if err != nil {
		return nil, err
	}
	queryUrl, _ = queryUrl.Parse(urlPath)
	req, _ := http.NewRequest(method, queryUrl.String(), bodyReader)
	req.Header.Set("Content-Type", "application/json")
	req = req.WithContext(httpClient.ctx)
	response, err := httpClient.client.Do(req)
	return response, err
}

// GoopentestbedApi oTG Testbed Model
type Api interface {
	api
	// Reserve reserves the testbed based on available devices from inventory.
	Reserve(testbed Testbed) (*string, error)
	// GetVersion description is TBD
	GetVersion() (Version, error)
	// GetLocalVersion provides version details of local client
	GetLocalVersion() Version
	// GetRemoteVersion provides version details received from remote server
	GetRemoteVersion() (Version, error)
	// SetVersionCompatibilityCheck allows enabling or disabling automatic version
	// compatibility check between client and server API spec version upon API call
	SetVersionCompatibilityCheck(bool)
	// CheckVersionCompatibility compares API spec version for local client and remote server,
	// and returns an error if they are not compatible according to Semantic Versioning 2.0.0
	CheckVersionCompatibility() error
}

func (api *goopentestbedApi) GetLocalVersion() Version {
	if api.versionMeta.localVersion == nil {
		api.versionMeta.localVersion = NewVersion().SetApiSpecVersion("0.0.4").SetSdkVersion("0.0.2")
	}

	return api.versionMeta.localVersion
}

func (api *goopentestbedApi) GetRemoteVersion() (Version, error) {
	if api.versionMeta.remoteVersion == nil {
		v, err := api.GetVersion()
		if err != nil {
			return nil, fmt.Errorf("could not fetch remote version: %v", err)
		}

		api.versionMeta.remoteVersion = v
	}

	return api.versionMeta.remoteVersion, nil
}

func (api *goopentestbedApi) SetVersionCompatibilityCheck(v bool) {
	api.versionMeta.checkVersion = v
}

func (api *goopentestbedApi) checkLocalRemoteVersionCompatibility() (error, error) {
	localVer := api.GetLocalVersion()
	remoteVer, err := api.GetRemoteVersion()
	if err != nil {
		return nil, err
	}
	err = checkClientServerVersionCompatibility(localVer.ApiSpecVersion(), remoteVer.ApiSpecVersion(), "API spec")
	if err != nil {
		return fmt.Errorf(
			"client SDK version '%s' is not compatible with server SDK version '%s': %v",
			localVer.SdkVersion(), remoteVer.SdkVersion(), err,
		), nil
	}

	return nil, nil
}

func (api *goopentestbedApi) checkLocalRemoteVersionCompatibilityOnce() error {
	if !api.versionMeta.checkVersion {
		return nil
	}

	if api.versionMeta.checkError != nil {
		return api.versionMeta.checkError
	}

	compatErr, apiErr := api.checkLocalRemoteVersionCompatibility()
	if compatErr != nil {
		api.versionMeta.checkError = compatErr
		return compatErr
	}
	if apiErr != nil {
		api.versionMeta.checkError = nil
		return apiErr
	}

	api.versionMeta.checkVersion = false
	api.versionMeta.checkError = nil
	return nil
}

func (api *goopentestbedApi) CheckVersionCompatibility() error {
	compatErr, apiErr := api.checkLocalRemoteVersionCompatibility()
	if compatErr != nil {
		return fmt.Errorf("version error: %v", compatErr)
	}
	if apiErr != nil {
		return apiErr
	}

	return nil
}

func (api *goopentestbedApi) Reserve(testbed Testbed) (*string, error) {

	if err := testbed.validate(); err != nil {
		return nil, err
	}

	if err := api.checkLocalRemoteVersionCompatibilityOnce(); err != nil {
		return nil, err
	}
	if api.hasHttpTransport() {
		return api.httpReserve(testbed)
	}
	if err := api.grpcConnect(); err != nil {
		return nil, err
	}
	request := opentestbed.ReserveRequest{Testbed: testbed.msg()}
	ctx, cancelFunc := context.WithTimeout(context.Background(), api.grpc.requestTimeout)
	defer cancelFunc()
	resp, err := api.grpcClient.Reserve(ctx, &request)
	if err != nil {
		if er, ok := fromGrpcError(err); ok {
			return nil, er
		}
		return nil, err
	}
	if resp.GetString_() != "" {
		status_code_value := resp.GetString_()
		return &status_code_value, nil
	}
	return nil, nil
}

func (api *goopentestbedApi) GetVersion() (Version, error) {

	if api.hasHttpTransport() {
		return api.httpGetVersion()
	}
	if err := api.grpcConnect(); err != nil {
		return nil, err
	}
	request := emptypb.Empty{}
	ctx, cancelFunc := context.WithTimeout(context.Background(), api.grpc.requestTimeout)
	defer cancelFunc()
	resp, err := api.grpcClient.GetVersion(ctx, &request)
	if err != nil {
		if er, ok := fromGrpcError(err); ok {
			return nil, er
		}
		return nil, err
	}
	ret := NewVersion()
	if resp.GetVersion() != nil {
		return ret.setMsg(resp.GetVersion()), nil
	}

	return ret, nil
}

func (api *goopentestbedApi) httpReserve(testbed Testbed) (*string, error) {
	testbedJson, err := testbed.Marshal().ToJson()
	if err != nil {
		return nil, err
	}
	resp, err := api.httpSendRecv("reserve", testbedJson, "POST")

	if err != nil {
		return nil, err
	}
	bodyBytes, err := io.ReadAll(resp.Body)
	defer resp.Body.Close()
	if err != nil {
		return nil, err
	}
	if resp.StatusCode == 200 {
		bodyString := string(bodyBytes)
		return &bodyString, nil
	} else {
		return nil, fromHttpError(resp.StatusCode, bodyBytes)
	}
}

func (api *goopentestbedApi) httpGetVersion() (Version, error) {
	resp, err := api.httpSendRecv("capabilities/version", "", "GET")
	if err != nil {
		return nil, err
	}
	bodyBytes, err := io.ReadAll(resp.Body)
	defer resp.Body.Close()
	if err != nil {
		return nil, err
	}
	if resp.StatusCode == 200 {
		obj := NewGetVersionResponse().Version()
		if err := obj.Unmarshal().FromJson(string(bodyBytes)); err != nil {
			return nil, err
		}
		return obj, nil
	} else {
		return nil, fromHttpError(resp.StatusCode, bodyBytes)
	}
}

// ***** Testbed *****
type testbed struct {
	validation
	obj           *opentestbed.Testbed
	marshaller    marshalTestbed
	unMarshaller  unMarshalTestbed
	devicesHolder TestbedDeviceIter
	linksHolder   TestbedLinkIter
}

func NewTestbed() Testbed {
	obj := testbed{obj: &opentestbed.Testbed{}}
	obj.setDefault()
	return &obj
}

func (obj *testbed) msg() *opentestbed.Testbed {
	return obj.obj
}

func (obj *testbed) setMsg(msg *opentestbed.Testbed) Testbed {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

type marshaltestbed struct {
	obj *testbed
}

type marshalTestbed interface {
	// ToProto marshals Testbed to protobuf object *opentestbed.Testbed
	ToProto() (*opentestbed.Testbed, error)
	// ToPbText marshals Testbed to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Testbed to YAML text
	ToYaml() (string, error)
	// ToJson marshals Testbed to JSON text
	ToJson() (string, error)
}

type unMarshaltestbed struct {
	obj *testbed
}

type unMarshalTestbed interface {
	// FromProto unmarshals Testbed from protobuf object *opentestbed.Testbed
	FromProto(msg *opentestbed.Testbed) (Testbed, error)
	// FromPbText unmarshals Testbed from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Testbed from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Testbed from JSON text
	FromJson(value string) error
}

func (obj *testbed) Marshal() marshalTestbed {
	if obj.marshaller == nil {
		obj.marshaller = &marshaltestbed{obj: obj}
	}
	return obj.marshaller
}

func (obj *testbed) Unmarshal() unMarshalTestbed {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshaltestbed{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshaltestbed) ToProto() (*opentestbed.Testbed, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshaltestbed) FromProto(msg *opentestbed.Testbed) (Testbed, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshaltestbed) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshaltestbed) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshaltestbed) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshaltestbed) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshaltestbed) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshaltestbed) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *testbed) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *testbed) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *testbed) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *testbed) Clone() (Testbed, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewTestbed()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *testbed) setNil() {
	obj.devicesHolder = nil
	obj.linksHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Testbed is a container for Testbed model.
type Testbed interface {
	Validation
	// msg marshals Testbed to protobuf object *opentestbed.Testbed
	// and doesn't set defaults
	msg() *opentestbed.Testbed
	// setMsg unmarshals Testbed from protobuf object *opentestbed.Testbed
	// and doesn't set defaults
	setMsg(*opentestbed.Testbed) Testbed
	// provides marshal interface
	Marshal() marshalTestbed
	// provides unmarshal interface
	Unmarshal() unMarshalTestbed
	// validate validates Testbed
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Testbed, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Devices returns TestbedDeviceIterIter, set in Testbed
	Devices() TestbedDeviceIter
	// Links returns TestbedLinkIterIter, set in Testbed
	Links() TestbedLinkIter
	setNil()
}

// Logical Device with list of logical ports
// Devices returns a []Device
func (obj *testbed) Devices() TestbedDeviceIter {
	if len(obj.obj.Devices) == 0 {
		obj.obj.Devices = []*opentestbed.Device{}
	}
	if obj.devicesHolder == nil {
		obj.devicesHolder = newTestbedDeviceIter(&obj.obj.Devices).setMsg(obj)
	}
	return obj.devicesHolder
}

type testbedDeviceIter struct {
	obj         *testbed
	deviceSlice []Device
	fieldPtr    *[]*opentestbed.Device
}

func newTestbedDeviceIter(ptr *[]*opentestbed.Device) TestbedDeviceIter {
	return &testbedDeviceIter{fieldPtr: ptr}
}

type TestbedDeviceIter interface {
	setMsg(*testbed) TestbedDeviceIter
	Items() []Device
	Add() Device
	Append(items ...Device) TestbedDeviceIter
	Set(index int, newObj Device) TestbedDeviceIter
	Clear() TestbedDeviceIter
	clearHolderSlice() TestbedDeviceIter
	appendHolderSlice(item Device) TestbedDeviceIter
}

func (obj *testbedDeviceIter) setMsg(msg *testbed) TestbedDeviceIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&device{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *testbedDeviceIter) Items() []Device {
	return obj.deviceSlice
}

func (obj *testbedDeviceIter) Add() Device {
	newObj := &opentestbed.Device{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &device{obj: newObj}
	newLibObj.setDefault()
	obj.deviceSlice = append(obj.deviceSlice, newLibObj)
	return newLibObj
}

func (obj *testbedDeviceIter) Append(items ...Device) TestbedDeviceIter {
	for _, item := range items {
		newObj := item.msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.deviceSlice = append(obj.deviceSlice, item)
	}
	return obj
}

func (obj *testbedDeviceIter) Set(index int, newObj Device) TestbedDeviceIter {
	(*obj.fieldPtr)[index] = newObj.msg()
	obj.deviceSlice[index] = newObj
	return obj
}
func (obj *testbedDeviceIter) Clear() TestbedDeviceIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Device{}
		obj.deviceSlice = []Device{}
	}
	return obj
}
func (obj *testbedDeviceIter) clearHolderSlice() TestbedDeviceIter {
	if len(obj.deviceSlice) > 0 {
		obj.deviceSlice = []Device{}
	}
	return obj
}
func (obj *testbedDeviceIter) appendHolderSlice(item Device) TestbedDeviceIter {
	obj.deviceSlice = append(obj.deviceSlice, item)
	return obj
}

// Interconnection of logical ports between logical devices.
// Links returns a []Link
func (obj *testbed) Links() TestbedLinkIter {
	if len(obj.obj.Links) == 0 {
		obj.obj.Links = []*opentestbed.Link{}
	}
	if obj.linksHolder == nil {
		obj.linksHolder = newTestbedLinkIter(&obj.obj.Links).setMsg(obj)
	}
	return obj.linksHolder
}

type testbedLinkIter struct {
	obj       *testbed
	linkSlice []Link
	fieldPtr  *[]*opentestbed.Link
}

func newTestbedLinkIter(ptr *[]*opentestbed.Link) TestbedLinkIter {
	return &testbedLinkIter{fieldPtr: ptr}
}

type TestbedLinkIter interface {
	setMsg(*testbed) TestbedLinkIter
	Items() []Link
	Add() Link
	Append(items ...Link) TestbedLinkIter
	Set(index int, newObj Link) TestbedLinkIter
	Clear() TestbedLinkIter
	clearHolderSlice() TestbedLinkIter
	appendHolderSlice(item Link) TestbedLinkIter
}

func (obj *testbedLinkIter) setMsg(msg *testbed) TestbedLinkIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&link{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *testbedLinkIter) Items() []Link {
	return obj.linkSlice
}

func (obj *testbedLinkIter) Add() Link {
	newObj := &opentestbed.Link{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &link{obj: newObj}
	newLibObj.setDefault()
	obj.linkSlice = append(obj.linkSlice, newLibObj)
	return newLibObj
}

func (obj *testbedLinkIter) Append(items ...Link) TestbedLinkIter {
	for _, item := range items {
		newObj := item.msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.linkSlice = append(obj.linkSlice, item)
	}
	return obj
}

func (obj *testbedLinkIter) Set(index int, newObj Link) TestbedLinkIter {
	(*obj.fieldPtr)[index] = newObj.msg()
	obj.linkSlice[index] = newObj
	return obj
}
func (obj *testbedLinkIter) Clear() TestbedLinkIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Link{}
		obj.linkSlice = []Link{}
	}
	return obj
}
func (obj *testbedLinkIter) clearHolderSlice() TestbedLinkIter {
	if len(obj.linkSlice) > 0 {
		obj.linkSlice = []Link{}
	}
	return obj
}
func (obj *testbedLinkIter) appendHolderSlice(item Link) TestbedLinkIter {
	obj.linkSlice = append(obj.linkSlice, item)
	return obj
}

func (obj *testbed) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if len(obj.obj.Devices) != 0 {

		if set_default {
			obj.Devices().clearHolderSlice()
			for _, item := range obj.obj.Devices {
				obj.Devices().appendHolderSlice(&device{obj: item})
			}
		}
		for _, item := range obj.Devices().Items() {
			item.validateObj(vObj, set_default)
		}

	}

	if len(obj.obj.Links) != 0 {

		if set_default {
			obj.Links().clearHolderSlice()
			for _, item := range obj.obj.Links {
				obj.Links().appendHolderSlice(&link{obj: item})
			}
		}
		for _, item := range obj.Links().Items() {
			item.validateObj(vObj, set_default)
		}

	}

}

func (obj *testbed) setDefault() {

}

// ***** ReserveResponse *****
type reserveResponse struct {
	validation
	obj          *opentestbed.ReserveResponse
	marshaller   marshalReserveResponse
	unMarshaller unMarshalReserveResponse
}

func NewReserveResponse() ReserveResponse {
	obj := reserveResponse{obj: &opentestbed.ReserveResponse{}}
	obj.setDefault()
	return &obj
}

func (obj *reserveResponse) msg() *opentestbed.ReserveResponse {
	return obj.obj
}

func (obj *reserveResponse) setMsg(msg *opentestbed.ReserveResponse) ReserveResponse {

	proto.Merge(obj.obj, msg)
	return obj
}

type marshalreserveResponse struct {
	obj *reserveResponse
}

type marshalReserveResponse interface {
	// ToProto marshals ReserveResponse to protobuf object *opentestbed.ReserveResponse
	ToProto() (*opentestbed.ReserveResponse, error)
	// ToPbText marshals ReserveResponse to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals ReserveResponse to YAML text
	ToYaml() (string, error)
	// ToJson marshals ReserveResponse to JSON text
	ToJson() (string, error)
}

type unMarshalreserveResponse struct {
	obj *reserveResponse
}

type unMarshalReserveResponse interface {
	// FromProto unmarshals ReserveResponse from protobuf object *opentestbed.ReserveResponse
	FromProto(msg *opentestbed.ReserveResponse) (ReserveResponse, error)
	// FromPbText unmarshals ReserveResponse from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals ReserveResponse from YAML text
	FromYaml(value string) error
	// FromJson unmarshals ReserveResponse from JSON text
	FromJson(value string) error
}

func (obj *reserveResponse) Marshal() marshalReserveResponse {
	if obj.marshaller == nil {
		obj.marshaller = &marshalreserveResponse{obj: obj}
	}
	return obj.marshaller
}

func (obj *reserveResponse) Unmarshal() unMarshalReserveResponse {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshalreserveResponse{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshalreserveResponse) ToProto() (*opentestbed.ReserveResponse, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshalreserveResponse) FromProto(msg *opentestbed.ReserveResponse) (ReserveResponse, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshalreserveResponse) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshalreserveResponse) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshalreserveResponse) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalreserveResponse) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshalreserveResponse) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalreserveResponse) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *reserveResponse) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *reserveResponse) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *reserveResponse) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *reserveResponse) Clone() (ReserveResponse, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewReserveResponse()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// ReserveResponse is description is TBD
type ReserveResponse interface {
	Validation
	// msg marshals ReserveResponse to protobuf object *opentestbed.ReserveResponse
	// and doesn't set defaults
	msg() *opentestbed.ReserveResponse
	// setMsg unmarshals ReserveResponse from protobuf object *opentestbed.ReserveResponse
	// and doesn't set defaults
	setMsg(*opentestbed.ReserveResponse) ReserveResponse
	// provides marshal interface
	Marshal() marshalReserveResponse
	// provides unmarshal interface
	Unmarshal() unMarshalReserveResponse
	// validate validates ReserveResponse
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (ReserveResponse, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// ResponseString returns string, set in ReserveResponse.
	ResponseString() string
	// SetResponseString assigns string provided by user to ReserveResponse
	SetResponseString(value string) ReserveResponse
	// HasResponseString checks if ResponseString has been set in ReserveResponse
	HasResponseString() bool
}

// description is TBD
// ResponseString returns a string
func (obj *reserveResponse) ResponseString() string {
	return obj.obj.String_
}

// description is TBD
// ResponseString returns a string
func (obj *reserveResponse) HasResponseString() bool {
	return obj.obj.String_ != ""
}

// description is TBD
// SetResponseString sets the string value in the ReserveResponse object
func (obj *reserveResponse) SetResponseString(value string) ReserveResponse {
	obj.obj.String_ = value
	return obj
}

func (obj *reserveResponse) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

}

func (obj *reserveResponse) setDefault() {

}

// ***** GetVersionResponse *****
type getVersionResponse struct {
	validation
	obj           *opentestbed.GetVersionResponse
	marshaller    marshalGetVersionResponse
	unMarshaller  unMarshalGetVersionResponse
	versionHolder Version
}

func NewGetVersionResponse() GetVersionResponse {
	obj := getVersionResponse{obj: &opentestbed.GetVersionResponse{}}
	obj.setDefault()
	return &obj
}

func (obj *getVersionResponse) msg() *opentestbed.GetVersionResponse {
	return obj.obj
}

func (obj *getVersionResponse) setMsg(msg *opentestbed.GetVersionResponse) GetVersionResponse {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

type marshalgetVersionResponse struct {
	obj *getVersionResponse
}

type marshalGetVersionResponse interface {
	// ToProto marshals GetVersionResponse to protobuf object *opentestbed.GetVersionResponse
	ToProto() (*opentestbed.GetVersionResponse, error)
	// ToPbText marshals GetVersionResponse to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals GetVersionResponse to YAML text
	ToYaml() (string, error)
	// ToJson marshals GetVersionResponse to JSON text
	ToJson() (string, error)
}

type unMarshalgetVersionResponse struct {
	obj *getVersionResponse
}

type unMarshalGetVersionResponse interface {
	// FromProto unmarshals GetVersionResponse from protobuf object *opentestbed.GetVersionResponse
	FromProto(msg *opentestbed.GetVersionResponse) (GetVersionResponse, error)
	// FromPbText unmarshals GetVersionResponse from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals GetVersionResponse from YAML text
	FromYaml(value string) error
	// FromJson unmarshals GetVersionResponse from JSON text
	FromJson(value string) error
}

func (obj *getVersionResponse) Marshal() marshalGetVersionResponse {
	if obj.marshaller == nil {
		obj.marshaller = &marshalgetVersionResponse{obj: obj}
	}
	return obj.marshaller
}

func (obj *getVersionResponse) Unmarshal() unMarshalGetVersionResponse {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshalgetVersionResponse{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshalgetVersionResponse) ToProto() (*opentestbed.GetVersionResponse, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshalgetVersionResponse) FromProto(msg *opentestbed.GetVersionResponse) (GetVersionResponse, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshalgetVersionResponse) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshalgetVersionResponse) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshalgetVersionResponse) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalgetVersionResponse) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshalgetVersionResponse) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalgetVersionResponse) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *getVersionResponse) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *getVersionResponse) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *getVersionResponse) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *getVersionResponse) Clone() (GetVersionResponse, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewGetVersionResponse()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *getVersionResponse) setNil() {
	obj.versionHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// GetVersionResponse is description is TBD
type GetVersionResponse interface {
	Validation
	// msg marshals GetVersionResponse to protobuf object *opentestbed.GetVersionResponse
	// and doesn't set defaults
	msg() *opentestbed.GetVersionResponse
	// setMsg unmarshals GetVersionResponse from protobuf object *opentestbed.GetVersionResponse
	// and doesn't set defaults
	setMsg(*opentestbed.GetVersionResponse) GetVersionResponse
	// provides marshal interface
	Marshal() marshalGetVersionResponse
	// provides unmarshal interface
	Unmarshal() unMarshalGetVersionResponse
	// validate validates GetVersionResponse
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (GetVersionResponse, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Version returns Version, set in GetVersionResponse.
	// Version is version details
	Version() Version
	// SetVersion assigns Version provided by user to GetVersionResponse.
	// Version is version details
	SetVersion(value Version) GetVersionResponse
	// HasVersion checks if Version has been set in GetVersionResponse
	HasVersion() bool
	setNil()
}

// description is TBD
// Version returns a Version
func (obj *getVersionResponse) Version() Version {
	if obj.obj.Version == nil {
		obj.obj.Version = NewVersion().msg()
	}
	if obj.versionHolder == nil {
		obj.versionHolder = &version{obj: obj.obj.Version}
	}
	return obj.versionHolder
}

// description is TBD
// Version returns a Version
func (obj *getVersionResponse) HasVersion() bool {
	return obj.obj.Version != nil
}

// description is TBD
// SetVersion sets the Version value in the GetVersionResponse object
func (obj *getVersionResponse) SetVersion(value Version) GetVersionResponse {

	obj.versionHolder = nil
	obj.obj.Version = value.msg()

	return obj
}

func (obj *getVersionResponse) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if obj.obj.Version != nil {

		obj.Version().validateObj(vObj, set_default)
	}

}

func (obj *getVersionResponse) setDefault() {

}

// ***** Device *****
type device struct {
	validation
	obj              *opentestbed.Device
	marshaller       marshalDevice
	unMarshaller     unMarshalDevice
	portsHolder      DevicePortIter
	attributesHolder DeviceAttributeIter
}

func NewDevice() Device {
	obj := device{obj: &opentestbed.Device{}}
	obj.setDefault()
	return &obj
}

func (obj *device) msg() *opentestbed.Device {
	return obj.obj
}

func (obj *device) setMsg(msg *opentestbed.Device) Device {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

type marshaldevice struct {
	obj *device
}

type marshalDevice interface {
	// ToProto marshals Device to protobuf object *opentestbed.Device
	ToProto() (*opentestbed.Device, error)
	// ToPbText marshals Device to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Device to YAML text
	ToYaml() (string, error)
	// ToJson marshals Device to JSON text
	ToJson() (string, error)
}

type unMarshaldevice struct {
	obj *device
}

type unMarshalDevice interface {
	// FromProto unmarshals Device from protobuf object *opentestbed.Device
	FromProto(msg *opentestbed.Device) (Device, error)
	// FromPbText unmarshals Device from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Device from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Device from JSON text
	FromJson(value string) error
}

func (obj *device) Marshal() marshalDevice {
	if obj.marshaller == nil {
		obj.marshaller = &marshaldevice{obj: obj}
	}
	return obj.marshaller
}

func (obj *device) Unmarshal() unMarshalDevice {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshaldevice{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshaldevice) ToProto() (*opentestbed.Device, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshaldevice) FromProto(msg *opentestbed.Device) (Device, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshaldevice) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshaldevice) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshaldevice) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshaldevice) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshaldevice) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshaldevice) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *device) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *device) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *device) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *device) Clone() (Device, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewDevice()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *device) setNil() {
	obj.portsHolder = nil
	obj.attributesHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Device is device.
type Device interface {
	Validation
	// msg marshals Device to protobuf object *opentestbed.Device
	// and doesn't set defaults
	msg() *opentestbed.Device
	// setMsg unmarshals Device from protobuf object *opentestbed.Device
	// and doesn't set defaults
	setMsg(*opentestbed.Device) Device
	// provides marshal interface
	Marshal() marshalDevice
	// provides unmarshal interface
	Unmarshal() unMarshalDevice
	// validate validates Device
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Device, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Id returns string, set in Device.
	Id() string
	// SetId assigns string provided by user to Device
	SetId(value string) Device
	// Name returns string, set in Device.
	Name() string
	// SetName assigns string provided by user to Device
	SetName(value string) Device
	// HasName checks if Name has been set in Device
	HasName() bool
	// Vendor returns string, set in Device.
	Vendor() string
	// SetVendor assigns string provided by user to Device
	SetVendor(value string) Device
	// HasVendor checks if Vendor has been set in Device
	HasVendor() bool
	// Model returns string, set in Device.
	Model() string
	// SetModel assigns string provided by user to Device
	SetModel(value string) Device
	// HasModel checks if Model has been set in Device
	HasModel() bool
	// Platform returns string, set in Device.
	Platform() string
	// SetPlatform assigns string provided by user to Device
	SetPlatform(value string) Device
	// HasPlatform checks if Platform has been set in Device
	HasPlatform() bool
	// Image returns string, set in Device.
	Image() string
	// SetImage assigns string provided by user to Device
	SetImage(value string) Device
	// HasImage checks if Image has been set in Device
	HasImage() bool
	// Ports returns DevicePortIterIter, set in Device
	Ports() DevicePortIter
	// Attributes returns DeviceAttributeIterIter, set in Device
	Attributes() DeviceAttributeIter
	// Role returns DeviceRoleEnum, set in Device
	Role() DeviceRoleEnum
	// SetRole assigns DeviceRoleEnum provided by user to Device
	SetRole(value DeviceRoleEnum) Device
	setNil()
}

// Globally unique id of an object. It also serves as the primary key for arrays of objects.
// Id returns a string
func (obj *device) Id() string {

	return *obj.obj.Id

}

// Globally unique id of an object. It also serves as the primary key for arrays of objects.
// SetId sets the string value in the Device object
func (obj *device) SetId(value string) Device {

	obj.obj.Id = &value
	return obj
}

// Name of the device that you want to match from the inventory
// Name returns a string
func (obj *device) Name() string {

	return *obj.obj.Name

}

// Name of the device that you want to match from the inventory
// Name returns a string
func (obj *device) HasName() bool {
	return obj.obj.Name != nil
}

// Name of the device that you want to match from the inventory
// SetName sets the string value in the Device object
func (obj *device) SetName(value string) Device {

	obj.obj.Name = &value
	return obj
}

// Vendor(manufacturer of the device)
// Vendor returns a string
func (obj *device) Vendor() string {

	return *obj.obj.Vendor

}

// Vendor(manufacturer of the device)
// Vendor returns a string
func (obj *device) HasVendor() bool {
	return obj.obj.Vendor != nil
}

// Vendor(manufacturer of the device)
// SetVendor sets the string value in the Device object
func (obj *device) SetVendor(value string) Device {

	obj.obj.Vendor = &value
	return obj
}

// Model(unique identification of the device type)
// Model returns a string
func (obj *device) Model() string {

	return *obj.obj.Model

}

// Model(unique identification of the device type)
// Model returns a string
func (obj *device) HasModel() bool {
	return obj.obj.Model != nil
}

// Model(unique identification of the device type)
// SetModel sets the string value in the Device object
func (obj *device) SetModel(value string) Device {

	obj.obj.Model = &value
	return obj
}

// Platform (describes a combination of operating system, applications, or other types of software that is supported by the device)
// Platform returns a string
func (obj *device) Platform() string {

	return *obj.obj.Platform

}

// Platform (describes a combination of operating system, applications, or other types of software that is supported by the device)
// Platform returns a string
func (obj *device) HasPlatform() bool {
	return obj.obj.Platform != nil
}

// Platform (describes a combination of operating system, applications, or other types of software that is supported by the device)
// SetPlatform sets the string value in the Device object
func (obj *device) SetPlatform(value string) Device {

	obj.obj.Platform = &value
	return obj
}

// Image (a unique software package installed on the device)
// Image returns a string
func (obj *device) Image() string {

	return *obj.obj.Image

}

// Image (a unique software package installed on the device)
// Image returns a string
func (obj *device) HasImage() bool {
	return obj.obj.Image != nil
}

// Image (a unique software package installed on the device)
// SetImage sets the string value in the Device object
func (obj *device) SetImage(value string) Device {

	obj.obj.Image = &value
	return obj
}

// List of Logical ports
// Ports returns a []Port
func (obj *device) Ports() DevicePortIter {
	if len(obj.obj.Ports) == 0 {
		obj.obj.Ports = []*opentestbed.Port{}
	}
	if obj.portsHolder == nil {
		obj.portsHolder = newDevicePortIter(&obj.obj.Ports).setMsg(obj)
	}
	return obj.portsHolder
}

type devicePortIter struct {
	obj       *device
	portSlice []Port
	fieldPtr  *[]*opentestbed.Port
}

func newDevicePortIter(ptr *[]*opentestbed.Port) DevicePortIter {
	return &devicePortIter{fieldPtr: ptr}
}

type DevicePortIter interface {
	setMsg(*device) DevicePortIter
	Items() []Port
	Add() Port
	Append(items ...Port) DevicePortIter
	Set(index int, newObj Port) DevicePortIter
	Clear() DevicePortIter
	clearHolderSlice() DevicePortIter
	appendHolderSlice(item Port) DevicePortIter
}

func (obj *devicePortIter) setMsg(msg *device) DevicePortIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&port{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *devicePortIter) Items() []Port {
	return obj.portSlice
}

func (obj *devicePortIter) Add() Port {
	newObj := &opentestbed.Port{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &port{obj: newObj}
	newLibObj.setDefault()
	obj.portSlice = append(obj.portSlice, newLibObj)
	return newLibObj
}

func (obj *devicePortIter) Append(items ...Port) DevicePortIter {
	for _, item := range items {
		newObj := item.msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.portSlice = append(obj.portSlice, item)
	}
	return obj
}

func (obj *devicePortIter) Set(index int, newObj Port) DevicePortIter {
	(*obj.fieldPtr)[index] = newObj.msg()
	obj.portSlice[index] = newObj
	return obj
}
func (obj *devicePortIter) Clear() DevicePortIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Port{}
		obj.portSlice = []Port{}
	}
	return obj
}
func (obj *devicePortIter) clearHolderSlice() DevicePortIter {
	if len(obj.portSlice) > 0 {
		obj.portSlice = []Port{}
	}
	return obj
}
func (obj *devicePortIter) appendHolderSlice(item Port) DevicePortIter {
	obj.portSlice = append(obj.portSlice, item)
	return obj
}

// attributes of the devices
// Attributes returns a []Attribute
func (obj *device) Attributes() DeviceAttributeIter {
	if len(obj.obj.Attributes) == 0 {
		obj.obj.Attributes = []*opentestbed.Attribute{}
	}
	if obj.attributesHolder == nil {
		obj.attributesHolder = newDeviceAttributeIter(&obj.obj.Attributes).setMsg(obj)
	}
	return obj.attributesHolder
}

type deviceAttributeIter struct {
	obj            *device
	attributeSlice []Attribute
	fieldPtr       *[]*opentestbed.Attribute
}

func newDeviceAttributeIter(ptr *[]*opentestbed.Attribute) DeviceAttributeIter {
	return &deviceAttributeIter{fieldPtr: ptr}
}

type DeviceAttributeIter interface {
	setMsg(*device) DeviceAttributeIter
	Items() []Attribute
	Add() Attribute
	Append(items ...Attribute) DeviceAttributeIter
	Set(index int, newObj Attribute) DeviceAttributeIter
	Clear() DeviceAttributeIter
	clearHolderSlice() DeviceAttributeIter
	appendHolderSlice(item Attribute) DeviceAttributeIter
}

func (obj *deviceAttributeIter) setMsg(msg *device) DeviceAttributeIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&attribute{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *deviceAttributeIter) Items() []Attribute {
	return obj.attributeSlice
}

func (obj *deviceAttributeIter) Add() Attribute {
	newObj := &opentestbed.Attribute{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &attribute{obj: newObj}
	newLibObj.setDefault()
	obj.attributeSlice = append(obj.attributeSlice, newLibObj)
	return newLibObj
}

func (obj *deviceAttributeIter) Append(items ...Attribute) DeviceAttributeIter {
	for _, item := range items {
		newObj := item.msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.attributeSlice = append(obj.attributeSlice, item)
	}
	return obj
}

func (obj *deviceAttributeIter) Set(index int, newObj Attribute) DeviceAttributeIter {
	(*obj.fieldPtr)[index] = newObj.msg()
	obj.attributeSlice[index] = newObj
	return obj
}
func (obj *deviceAttributeIter) Clear() DeviceAttributeIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Attribute{}
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *deviceAttributeIter) clearHolderSlice() DeviceAttributeIter {
	if len(obj.attributeSlice) > 0 {
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *deviceAttributeIter) appendHolderSlice(item Attribute) DeviceAttributeIter {
	obj.attributeSlice = append(obj.attributeSlice, item)
	return obj
}

type DeviceRoleEnum string

// Enum of Role on Device
var DeviceRole = struct {
	DUT DeviceRoleEnum
	ATE DeviceRoleEnum
	L1S DeviceRoleEnum
}{
	DUT: DeviceRoleEnum("DUT"),
	ATE: DeviceRoleEnum("ATE"),
	L1S: DeviceRoleEnum("L1S"),
}

func (obj *device) Role() DeviceRoleEnum {
	return DeviceRoleEnum(obj.obj.Role.Enum().String())
}

func (obj *device) SetRole(value DeviceRoleEnum) Device {
	intValue, ok := opentestbed.Device_Role_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on DeviceRoleEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Device_Role_Enum(intValue)
	obj.obj.Role = &enumValue

	return obj
}

func (obj *device) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Id is required
	if obj.obj.Id == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Id is required field on interface Device")
	}

	if len(obj.obj.Ports) != 0 {

		if set_default {
			obj.Ports().clearHolderSlice()
			for _, item := range obj.obj.Ports {
				obj.Ports().appendHolderSlice(&port{obj: item})
			}
		}
		for _, item := range obj.Ports().Items() {
			item.validateObj(vObj, set_default)
		}

	}

	if len(obj.obj.Attributes) != 0 {

		if set_default {
			obj.Attributes().clearHolderSlice()
			for _, item := range obj.obj.Attributes {
				obj.Attributes().appendHolderSlice(&attribute{obj: item})
			}
		}
		for _, item := range obj.Attributes().Items() {
			item.validateObj(vObj, set_default)
		}

	}

	// Role is required
	if obj.obj.Role == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Role is required field on interface Device")
	}
}

func (obj *device) setDefault() {

}

// ***** Link *****
type link struct {
	validation
	obj          *opentestbed.Link
	marshaller   marshalLink
	unMarshaller unMarshalLink
	srcHolder    LinkSrc
	dstHolder    LinkDst
}

func NewLink() Link {
	obj := link{obj: &opentestbed.Link{}}
	obj.setDefault()
	return &obj
}

func (obj *link) msg() *opentestbed.Link {
	return obj.obj
}

func (obj *link) setMsg(msg *opentestbed.Link) Link {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

type marshallink struct {
	obj *link
}

type marshalLink interface {
	// ToProto marshals Link to protobuf object *opentestbed.Link
	ToProto() (*opentestbed.Link, error)
	// ToPbText marshals Link to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Link to YAML text
	ToYaml() (string, error)
	// ToJson marshals Link to JSON text
	ToJson() (string, error)
}

type unMarshallink struct {
	obj *link
}

type unMarshalLink interface {
	// FromProto unmarshals Link from protobuf object *opentestbed.Link
	FromProto(msg *opentestbed.Link) (Link, error)
	// FromPbText unmarshals Link from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Link from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Link from JSON text
	FromJson(value string) error
}

func (obj *link) Marshal() marshalLink {
	if obj.marshaller == nil {
		obj.marshaller = &marshallink{obj: obj}
	}
	return obj.marshaller
}

func (obj *link) Unmarshal() unMarshalLink {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshallink{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshallink) ToProto() (*opentestbed.Link, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshallink) FromProto(msg *opentestbed.Link) (Link, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshallink) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshallink) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshallink) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshallink) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshallink) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshallink) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *link) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *link) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *link) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *link) Clone() (Link, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewLink()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *link) setNil() {
	obj.srcHolder = nil
	obj.dstHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Link is device.
type Link interface {
	Validation
	// msg marshals Link to protobuf object *opentestbed.Link
	// and doesn't set defaults
	msg() *opentestbed.Link
	// setMsg unmarshals Link from protobuf object *opentestbed.Link
	// and doesn't set defaults
	setMsg(*opentestbed.Link) Link
	// provides marshal interface
	Marshal() marshalLink
	// provides unmarshal interface
	Unmarshal() unMarshalLink
	// validate validates Link
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Link, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Src returns LinkSrc, set in Link.
	// LinkSrc is src for the link.
	Src() LinkSrc
	// SetSrc assigns LinkSrc provided by user to Link.
	// LinkSrc is src for the link.
	SetSrc(value LinkSrc) Link
	// HasSrc checks if Src has been set in Link
	HasSrc() bool
	// Dst returns LinkDst, set in Link.
	// LinkDst is dst for the link.
	Dst() LinkDst
	// SetDst assigns LinkDst provided by user to Link.
	// LinkDst is dst for the link.
	SetDst(value LinkDst) Link
	// HasDst checks if Dst has been set in Link
	HasDst() bool
	setNil()
}

// description is TBD
// Src returns a LinkSrc
func (obj *link) Src() LinkSrc {
	if obj.obj.Src == nil {
		obj.obj.Src = NewLinkSrc().msg()
	}
	if obj.srcHolder == nil {
		obj.srcHolder = &linkSrc{obj: obj.obj.Src}
	}
	return obj.srcHolder
}

// description is TBD
// Src returns a LinkSrc
func (obj *link) HasSrc() bool {
	return obj.obj.Src != nil
}

// description is TBD
// SetSrc sets the LinkSrc value in the Link object
func (obj *link) SetSrc(value LinkSrc) Link {

	obj.srcHolder = nil
	obj.obj.Src = value.msg()

	return obj
}

// description is TBD
// Dst returns a LinkDst
func (obj *link) Dst() LinkDst {
	if obj.obj.Dst == nil {
		obj.obj.Dst = NewLinkDst().msg()
	}
	if obj.dstHolder == nil {
		obj.dstHolder = &linkDst{obj: obj.obj.Dst}
	}
	return obj.dstHolder
}

// description is TBD
// Dst returns a LinkDst
func (obj *link) HasDst() bool {
	return obj.obj.Dst != nil
}

// description is TBD
// SetDst sets the LinkDst value in the Link object
func (obj *link) SetDst(value LinkDst) Link {

	obj.dstHolder = nil
	obj.obj.Dst = value.msg()

	return obj
}

func (obj *link) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if obj.obj.Src != nil {

		obj.Src().validateObj(vObj, set_default)
	}

	if obj.obj.Dst != nil {

		obj.Dst().validateObj(vObj, set_default)
	}

}

func (obj *link) setDefault() {

}

// ***** Error *****
type _error struct {
	validation
	obj          *opentestbed.Error
	marshaller   marshalError
	unMarshaller unMarshalError
}

func NewError() Error {
	obj := _error{obj: &opentestbed.Error{}}
	obj.setDefault()
	return &obj
}

func (obj *_error) msg() *opentestbed.Error {
	return obj.obj
}

func (obj *_error) setMsg(msg *opentestbed.Error) Error {

	proto.Merge(obj.obj, msg)
	return obj
}

type marshal_error struct {
	obj *_error
}

type marshalError interface {
	// ToProto marshals Error to protobuf object *opentestbed.Error
	ToProto() (*opentestbed.Error, error)
	// ToPbText marshals Error to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Error to YAML text
	ToYaml() (string, error)
	// ToJson marshals Error to JSON text
	ToJson() (string, error)
}

type unMarshal_error struct {
	obj *_error
}

type unMarshalError interface {
	// FromProto unmarshals Error from protobuf object *opentestbed.Error
	FromProto(msg *opentestbed.Error) (Error, error)
	// FromPbText unmarshals Error from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Error from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Error from JSON text
	FromJson(value string) error
}

func (obj *_error) Marshal() marshalError {
	if obj.marshaller == nil {
		obj.marshaller = &marshal_error{obj: obj}
	}
	return obj.marshaller
}

func (obj *_error) Unmarshal() unMarshalError {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshal_error{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshal_error) ToProto() (*opentestbed.Error, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshal_error) FromProto(msg *opentestbed.Error) (Error, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshal_error) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshal_error) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshal_error) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshal_error) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshal_error) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshal_error) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *_error) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *_error) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *_error) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *_error) Clone() (Error, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewError()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// Error is error response generated while serving API request.
type Error interface {
	Validation
	// msg marshals Error to protobuf object *opentestbed.Error
	// and doesn't set defaults
	msg() *opentestbed.Error
	// setMsg unmarshals Error from protobuf object *opentestbed.Error
	// and doesn't set defaults
	setMsg(*opentestbed.Error) Error
	// provides marshal interface
	Marshal() marshalError
	// provides unmarshal interface
	Unmarshal() unMarshalError
	// validate validates Error
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Error, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Code returns int32, set in Error.
	Code() int32
	// SetCode assigns int32 provided by user to Error
	SetCode(value int32) Error
	// Kind returns ErrorKindEnum, set in Error
	Kind() ErrorKindEnum
	// SetKind assigns ErrorKindEnum provided by user to Error
	SetKind(value ErrorKindEnum) Error
	// HasKind checks if Kind has been set in Error
	HasKind() bool
	// Errors returns []string, set in Error.
	Errors() []string
	// SetErrors assigns []string provided by user to Error
	SetErrors(value []string) Error
	// implement Error function for implementingnative Error Interface.
	Error() string
}

func (obj *_error) Error() string {
	json, err := obj.Marshal().ToJson()
	if err != nil {
		return fmt.Sprintf("could not convert Error to JSON: %v", err)
	}
	return json
}

// Numeric status code based on the underlying transport being used.
// The API server MUST set this code explicitly based on following references:
// - HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5
// - HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6
// - gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html
// Code returns a int32
func (obj *_error) Code() int32 {

	return *obj.obj.Code

}

// Numeric status code based on the underlying transport being used.
// The API server MUST set this code explicitly based on following references:
// - HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5
// - HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6
// - gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html
// SetCode sets the int32 value in the Error object
func (obj *_error) SetCode(value int32) Error {

	obj.obj.Code = &value
	return obj
}

type ErrorKindEnum string

// Enum of Kind on Error
var ErrorKind = struct {
	VALIDATION ErrorKindEnum
	INTERNAL   ErrorKindEnum
}{
	VALIDATION: ErrorKindEnum("validation"),
	INTERNAL:   ErrorKindEnum("internal"),
}

func (obj *_error) Kind() ErrorKindEnum {
	return ErrorKindEnum(obj.obj.Kind.Enum().String())
}

// Classification of error originating from within API server that may not be mapped to the value in `code`.
// Absence of this field may indicate that the error did not originate from within API server.
// Kind returns a string
func (obj *_error) HasKind() bool {
	return obj.obj.Kind != nil
}

func (obj *_error) SetKind(value ErrorKindEnum) Error {
	intValue, ok := opentestbed.Error_Kind_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on ErrorKindEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Error_Kind_Enum(intValue)
	obj.obj.Kind = &enumValue

	return obj
}

// List of error messages generated while executing the request.
// Errors returns a []string
func (obj *_error) Errors() []string {
	if obj.obj.Errors == nil {
		obj.obj.Errors = make([]string, 0)
	}
	return obj.obj.Errors
}

// List of error messages generated while executing the request.
// SetErrors sets the []string value in the Error object
func (obj *_error) SetErrors(value []string) Error {

	if obj.obj.Errors == nil {
		obj.obj.Errors = make([]string, 0)
	}
	obj.obj.Errors = value

	return obj
}

func (obj *_error) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Code is required
	if obj.obj.Code == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Code is required field on interface Error")
	}
}

func (obj *_error) setDefault() {

}

// ***** Version *****
type version struct {
	validation
	obj          *opentestbed.Version
	marshaller   marshalVersion
	unMarshaller unMarshalVersion
}

func NewVersion() Version {
	obj := version{obj: &opentestbed.Version{}}
	obj.setDefault()
	return &obj
}

func (obj *version) msg() *opentestbed.Version {
	return obj.obj
}

func (obj *version) setMsg(msg *opentestbed.Version) Version {

	proto.Merge(obj.obj, msg)
	return obj
}

type marshalversion struct {
	obj *version
}

type marshalVersion interface {
	// ToProto marshals Version to protobuf object *opentestbed.Version
	ToProto() (*opentestbed.Version, error)
	// ToPbText marshals Version to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Version to YAML text
	ToYaml() (string, error)
	// ToJson marshals Version to JSON text
	ToJson() (string, error)
}

type unMarshalversion struct {
	obj *version
}

type unMarshalVersion interface {
	// FromProto unmarshals Version from protobuf object *opentestbed.Version
	FromProto(msg *opentestbed.Version) (Version, error)
	// FromPbText unmarshals Version from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Version from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Version from JSON text
	FromJson(value string) error
}

func (obj *version) Marshal() marshalVersion {
	if obj.marshaller == nil {
		obj.marshaller = &marshalversion{obj: obj}
	}
	return obj.marshaller
}

func (obj *version) Unmarshal() unMarshalVersion {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshalversion{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshalversion) ToProto() (*opentestbed.Version, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshalversion) FromProto(msg *opentestbed.Version) (Version, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshalversion) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshalversion) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshalversion) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalversion) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshalversion) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalversion) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *version) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *version) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *version) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *version) Clone() (Version, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewVersion()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// Version is version details
type Version interface {
	Validation
	// msg marshals Version to protobuf object *opentestbed.Version
	// and doesn't set defaults
	msg() *opentestbed.Version
	// setMsg unmarshals Version from protobuf object *opentestbed.Version
	// and doesn't set defaults
	setMsg(*opentestbed.Version) Version
	// provides marshal interface
	Marshal() marshalVersion
	// provides unmarshal interface
	Unmarshal() unMarshalVersion
	// validate validates Version
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Version, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// ApiSpecVersion returns string, set in Version.
	ApiSpecVersion() string
	// SetApiSpecVersion assigns string provided by user to Version
	SetApiSpecVersion(value string) Version
	// HasApiSpecVersion checks if ApiSpecVersion has been set in Version
	HasApiSpecVersion() bool
	// SdkVersion returns string, set in Version.
	SdkVersion() string
	// SetSdkVersion assigns string provided by user to Version
	SetSdkVersion(value string) Version
	// HasSdkVersion checks if SdkVersion has been set in Version
	HasSdkVersion() bool
	// AppVersion returns string, set in Version.
	AppVersion() string
	// SetAppVersion assigns string provided by user to Version
	SetAppVersion(value string) Version
	// HasAppVersion checks if AppVersion has been set in Version
	HasAppVersion() bool
}

// Version of API specification
// ApiSpecVersion returns a string
func (obj *version) ApiSpecVersion() string {

	return *obj.obj.ApiSpecVersion

}

// Version of API specification
// ApiSpecVersion returns a string
func (obj *version) HasApiSpecVersion() bool {
	return obj.obj.ApiSpecVersion != nil
}

// Version of API specification
// SetApiSpecVersion sets the string value in the Version object
func (obj *version) SetApiSpecVersion(value string) Version {

	obj.obj.ApiSpecVersion = &value
	return obj
}

// Version of SDK generated from API specification
// SdkVersion returns a string
func (obj *version) SdkVersion() string {

	return *obj.obj.SdkVersion

}

// Version of SDK generated from API specification
// SdkVersion returns a string
func (obj *version) HasSdkVersion() bool {
	return obj.obj.SdkVersion != nil
}

// Version of SDK generated from API specification
// SetSdkVersion sets the string value in the Version object
func (obj *version) SetSdkVersion(value string) Version {

	obj.obj.SdkVersion = &value
	return obj
}

// Version of application consuming or serving the API
// AppVersion returns a string
func (obj *version) AppVersion() string {

	return *obj.obj.AppVersion

}

// Version of application consuming or serving the API
// AppVersion returns a string
func (obj *version) HasAppVersion() bool {
	return obj.obj.AppVersion != nil
}

// Version of application consuming or serving the API
// SetAppVersion sets the string value in the Version object
func (obj *version) SetAppVersion(value string) Version {

	obj.obj.AppVersion = &value
	return obj
}

func (obj *version) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

}

func (obj *version) setDefault() {
	if obj.obj.ApiSpecVersion == nil {
		obj.SetApiSpecVersion("")
	}
	if obj.obj.SdkVersion == nil {
		obj.SetSdkVersion("")
	}
	if obj.obj.AppVersion == nil {
		obj.SetAppVersion("")
	}

}

// ***** Port *****
type port struct {
	validation
	obj              *opentestbed.Port
	marshaller       marshalPort
	unMarshaller     unMarshalPort
	attributesHolder PortAttributeIter
}

func NewPort() Port {
	obj := port{obj: &opentestbed.Port{}}
	obj.setDefault()
	return &obj
}

func (obj *port) msg() *opentestbed.Port {
	return obj.obj
}

func (obj *port) setMsg(msg *opentestbed.Port) Port {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

type marshalport struct {
	obj *port
}

type marshalPort interface {
	// ToProto marshals Port to protobuf object *opentestbed.Port
	ToProto() (*opentestbed.Port, error)
	// ToPbText marshals Port to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Port to YAML text
	ToYaml() (string, error)
	// ToJson marshals Port to JSON text
	ToJson() (string, error)
}

type unMarshalport struct {
	obj *port
}

type unMarshalPort interface {
	// FromProto unmarshals Port from protobuf object *opentestbed.Port
	FromProto(msg *opentestbed.Port) (Port, error)
	// FromPbText unmarshals Port from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Port from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Port from JSON text
	FromJson(value string) error
}

func (obj *port) Marshal() marshalPort {
	if obj.marshaller == nil {
		obj.marshaller = &marshalport{obj: obj}
	}
	return obj.marshaller
}

func (obj *port) Unmarshal() unMarshalPort {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshalport{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshalport) ToProto() (*opentestbed.Port, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshalport) FromProto(msg *opentestbed.Port) (Port, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshalport) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshalport) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshalport) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalport) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshalport) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalport) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	m.obj.setNil()
	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *port) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *port) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *port) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *port) Clone() (Port, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewPort()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *port) setNil() {
	obj.attributesHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Port is local Port for Testbed Reservation Service.
type Port interface {
	Validation
	// msg marshals Port to protobuf object *opentestbed.Port
	// and doesn't set defaults
	msg() *opentestbed.Port
	// setMsg unmarshals Port from protobuf object *opentestbed.Port
	// and doesn't set defaults
	setMsg(*opentestbed.Port) Port
	// provides marshal interface
	Marshal() marshalPort
	// provides unmarshal interface
	Unmarshal() unMarshalPort
	// validate validates Port
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Port, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Id returns string, set in Port.
	Id() string
	// SetId assigns string provided by user to Port
	SetId(value string) Port
	// Name returns string, set in Port.
	Name() string
	// SetName assigns string provided by user to Port
	SetName(value string) Port
	// HasName checks if Name has been set in Port
	HasName() bool
	// Pmd returns PortPmdEnum, set in Port
	Pmd() PortPmdEnum
	// SetPmd assigns PortPmdEnum provided by user to Port
	SetPmd(value PortPmdEnum) Port
	// HasPmd checks if Pmd has been set in Port
	HasPmd() bool
	// Speed returns PortSpeedEnum, set in Port
	Speed() PortSpeedEnum
	// SetSpeed assigns PortSpeedEnum provided by user to Port
	SetSpeed(value PortSpeedEnum) Port
	// HasSpeed checks if Speed has been set in Port
	HasSpeed() bool
	// Transceiver returns string, set in Port.
	Transceiver() string
	// SetTransceiver assigns string provided by user to Port
	SetTransceiver(value string) Port
	// HasTransceiver checks if Transceiver has been set in Port
	HasTransceiver() bool
	// Attributes returns PortAttributeIterIter, set in Port
	Attributes() PortAttributeIter
	setNil()
}

// Logical identifier for the port
// Id returns a string
func (obj *port) Id() string {

	return *obj.obj.Id

}

// Logical identifier for the port
// SetId sets the string value in the Port object
func (obj *port) SetId(value string) Port {

	obj.obj.Id = &value
	return obj
}

// Name of the port on a device that you want to match from the inventory.
// Name returns a string
func (obj *port) Name() string {

	return *obj.obj.Name

}

// Name of the port on a device that you want to match from the inventory.
// Name returns a string
func (obj *port) HasName() bool {
	return obj.obj.Name != nil
}

// Name of the port on a device that you want to match from the inventory.
// SetName sets the string value in the Port object
func (obj *port) SetName(value string) Port {

	obj.obj.Name = &value
	return obj
}

type PortPmdEnum string

// Enum of Pmd on Port
var PortPmd = struct {
	PMD_UNSPECIFIED    PortPmdEnum
	PMD_10GBASE_LRM    PortPmdEnum
	PMD_10GBASE_LR     PortPmdEnum
	PMD_10GBASE_ZR     PortPmdEnum
	PMD_10GBASE_ER     PortPmdEnum
	PMD_10GBASE_SR     PortPmdEnum
	PMD_40GBASE_CR4    PortPmdEnum
	PMD_40GBASE_SR4    PortPmdEnum
	PMD_40GBASE_LR4    PortPmdEnum
	PMD_40GBASE_ER4    PortPmdEnum
	PMD_40GBASE_PSM4   PortPmdEnum
	PMD_4X10GBASE_LR   PortPmdEnum
	PMD_4X10GBASE_SR   PortPmdEnum
	PMD_100G_AOC       PortPmdEnum
	PMD_100G_ACC       PortPmdEnum
	PMD_100GBASE_SR10  PortPmdEnum
	PMD_100GBASE_SR4   PortPmdEnum
	PMD_100GBASE_LR4   PortPmdEnum
	PMD_100GBASE_ER4   PortPmdEnum
	PMD_100GBASE_CWDM4 PortPmdEnum
	PMD_100GBASE_CLR4  PortPmdEnum
	PMD_100GBASE_PSM4  PortPmdEnum
	PMD_100GBASE_CR4   PortPmdEnum
	PMD_100GBASE_FR    PortPmdEnum
	PMD_400GBASE_ZR    PortPmdEnum
	PMD_400GBASE_LR4   PortPmdEnum
	PMD_400GBASE_FR4   PortPmdEnum
	PMD_400GBASE_LR8   PortPmdEnum
	PMD_400GBASE_DR4   PortPmdEnum
	PMD_100GBASE_DR    PortPmdEnum
}{
	PMD_UNSPECIFIED:    PortPmdEnum("PMD_UNSPECIFIED"),
	PMD_10GBASE_LRM:    PortPmdEnum("PMD_10GBASE_LRM"),
	PMD_10GBASE_LR:     PortPmdEnum("PMD_10GBASE_LR"),
	PMD_10GBASE_ZR:     PortPmdEnum("PMD_10GBASE_ZR"),
	PMD_10GBASE_ER:     PortPmdEnum("PMD_10GBASE_ER"),
	PMD_10GBASE_SR:     PortPmdEnum("PMD_10GBASE_SR"),
	PMD_40GBASE_CR4:    PortPmdEnum("PMD_40GBASE_CR4"),
	PMD_40GBASE_SR4:    PortPmdEnum("PMD_40GBASE_SR4"),
	PMD_40GBASE_LR4:    PortPmdEnum("PMD_40GBASE_LR4"),
	PMD_40GBASE_ER4:    PortPmdEnum("PMD_40GBASE_ER4"),
	PMD_40GBASE_PSM4:   PortPmdEnum("PMD_40GBASE_PSM4"),
	PMD_4X10GBASE_LR:   PortPmdEnum("PMD_4X10GBASE_LR"),
	PMD_4X10GBASE_SR:   PortPmdEnum("PMD_4X10GBASE_SR"),
	PMD_100G_AOC:       PortPmdEnum("PMD_100G_AOC"),
	PMD_100G_ACC:       PortPmdEnum("PMD_100G_ACC"),
	PMD_100GBASE_SR10:  PortPmdEnum("PMD_100GBASE_SR10"),
	PMD_100GBASE_SR4:   PortPmdEnum("PMD_100GBASE_SR4"),
	PMD_100GBASE_LR4:   PortPmdEnum("PMD_100GBASE_LR4"),
	PMD_100GBASE_ER4:   PortPmdEnum("PMD_100GBASE_ER4"),
	PMD_100GBASE_CWDM4: PortPmdEnum("PMD_100GBASE_CWDM4"),
	PMD_100GBASE_CLR4:  PortPmdEnum("PMD_100GBASE_CLR4"),
	PMD_100GBASE_PSM4:  PortPmdEnum("PMD_100GBASE_PSM4"),
	PMD_100GBASE_CR4:   PortPmdEnum("PMD_100GBASE_CR4"),
	PMD_100GBASE_FR:    PortPmdEnum("PMD_100GBASE_FR"),
	PMD_400GBASE_ZR:    PortPmdEnum("PMD_400GBASE_ZR"),
	PMD_400GBASE_LR4:   PortPmdEnum("PMD_400GBASE_LR4"),
	PMD_400GBASE_FR4:   PortPmdEnum("PMD_400GBASE_FR4"),
	PMD_400GBASE_LR8:   PortPmdEnum("PMD_400GBASE_LR8"),
	PMD_400GBASE_DR4:   PortPmdEnum("PMD_400GBASE_DR4"),
	PMD_100GBASE_DR:    PortPmdEnum("PMD_100GBASE_DR"),
}

func (obj *port) Pmd() PortPmdEnum {
	return PortPmdEnum(obj.obj.Pmd.Enum().String())
}

// Physical medium dependent of the port.
// This should be kept in sync with the values specified in OpenConfig:
// https://github.com/openconfig/public/blob/master/release/models/optical-transport/openconfig-transport-types.yang
// Pmd returns a string
func (obj *port) HasPmd() bool {
	return obj.obj.Pmd != nil
}

func (obj *port) SetPmd(value PortPmdEnum) Port {
	intValue, ok := opentestbed.Port_Pmd_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on PortPmdEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Port_Pmd_Enum(intValue)
	obj.obj.Pmd = &enumValue

	return obj
}

type PortSpeedEnum string

// Enum of Speed on Port
var PortSpeed = struct {
	SPEED_UNSPECIFIED PortSpeedEnum
	S_1GB             PortSpeedEnum
	S_5GB             PortSpeedEnum
	S_10GB            PortSpeedEnum
	S_25GB            PortSpeedEnum
	S_40GB            PortSpeedEnum
	S_50GB            PortSpeedEnum
	S_100GB           PortSpeedEnum
	S_200GB           PortSpeedEnum
	S_400GB           PortSpeedEnum
}{
	SPEED_UNSPECIFIED: PortSpeedEnum("SPEED_UNSPECIFIED"),
	S_1GB:             PortSpeedEnum("S_1GB"),
	S_5GB:             PortSpeedEnum("S_5GB"),
	S_10GB:            PortSpeedEnum("S_10GB"),
	S_25GB:            PortSpeedEnum("S_25GB"),
	S_40GB:            PortSpeedEnum("S_40GB"),
	S_50GB:            PortSpeedEnum("S_50GB"),
	S_100GB:           PortSpeedEnum("S_100GB"),
	S_200GB:           PortSpeedEnum("S_200GB"),
	S_400GB:           PortSpeedEnum("S_400GB"),
}

func (obj *port) Speed() PortSpeedEnum {
	return PortSpeedEnum(obj.obj.Speed.Enum().String())
}

// description is TBD
// Speed returns a string
func (obj *port) HasSpeed() bool {
	return obj.obj.Speed != nil
}

func (obj *port) SetSpeed(value PortSpeedEnum) Port {
	intValue, ok := opentestbed.Port_Speed_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on PortSpeedEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Port_Speed_Enum(intValue)
	obj.obj.Speed = &enumValue

	return obj
}

// description is TBD
// Transceiver returns a string
func (obj *port) Transceiver() string {

	return *obj.obj.Transceiver

}

// description is TBD
// Transceiver returns a string
func (obj *port) HasTransceiver() bool {
	return obj.obj.Transceiver != nil
}

// description is TBD
// SetTransceiver sets the string value in the Port object
func (obj *port) SetTransceiver(value string) Port {

	obj.obj.Transceiver = &value
	return obj
}

// attributes of the device ports that specify an internal architecture behind the port, for example: NPU #, NPU Core, Slice #,
// Attributes returns a []Attribute
func (obj *port) Attributes() PortAttributeIter {
	if len(obj.obj.Attributes) == 0 {
		obj.obj.Attributes = []*opentestbed.Attribute{}
	}
	if obj.attributesHolder == nil {
		obj.attributesHolder = newPortAttributeIter(&obj.obj.Attributes).setMsg(obj)
	}
	return obj.attributesHolder
}

type portAttributeIter struct {
	obj            *port
	attributeSlice []Attribute
	fieldPtr       *[]*opentestbed.Attribute
}

func newPortAttributeIter(ptr *[]*opentestbed.Attribute) PortAttributeIter {
	return &portAttributeIter{fieldPtr: ptr}
}

type PortAttributeIter interface {
	setMsg(*port) PortAttributeIter
	Items() []Attribute
	Add() Attribute
	Append(items ...Attribute) PortAttributeIter
	Set(index int, newObj Attribute) PortAttributeIter
	Clear() PortAttributeIter
	clearHolderSlice() PortAttributeIter
	appendHolderSlice(item Attribute) PortAttributeIter
}

func (obj *portAttributeIter) setMsg(msg *port) PortAttributeIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&attribute{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *portAttributeIter) Items() []Attribute {
	return obj.attributeSlice
}

func (obj *portAttributeIter) Add() Attribute {
	newObj := &opentestbed.Attribute{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &attribute{obj: newObj}
	newLibObj.setDefault()
	obj.attributeSlice = append(obj.attributeSlice, newLibObj)
	return newLibObj
}

func (obj *portAttributeIter) Append(items ...Attribute) PortAttributeIter {
	for _, item := range items {
		newObj := item.msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.attributeSlice = append(obj.attributeSlice, item)
	}
	return obj
}

func (obj *portAttributeIter) Set(index int, newObj Attribute) PortAttributeIter {
	(*obj.fieldPtr)[index] = newObj.msg()
	obj.attributeSlice[index] = newObj
	return obj
}
func (obj *portAttributeIter) Clear() PortAttributeIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Attribute{}
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *portAttributeIter) clearHolderSlice() PortAttributeIter {
	if len(obj.attributeSlice) > 0 {
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *portAttributeIter) appendHolderSlice(item Attribute) PortAttributeIter {
	obj.attributeSlice = append(obj.attributeSlice, item)
	return obj
}

func (obj *port) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Id is required
	if obj.obj.Id == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Id is required field on interface Port")
	}

	if len(obj.obj.Attributes) != 0 {

		if set_default {
			obj.Attributes().clearHolderSlice()
			for _, item := range obj.obj.Attributes {
				obj.Attributes().appendHolderSlice(&attribute{obj: item})
			}
		}
		for _, item := range obj.Attributes().Items() {
			item.validateObj(vObj, set_default)
		}

	}

}

func (obj *port) setDefault() {
	if obj.obj.Pmd == nil {
		obj.SetPmd(PortPmd.PMD_UNSPECIFIED)

	}
	if obj.obj.Speed == nil {
		obj.SetSpeed(PortSpeed.SPEED_UNSPECIFIED)

	}

}

// ***** Attribute *****
type attribute struct {
	validation
	obj          *opentestbed.Attribute
	marshaller   marshalAttribute
	unMarshaller unMarshalAttribute
}

func NewAttribute() Attribute {
	obj := attribute{obj: &opentestbed.Attribute{}}
	obj.setDefault()
	return &obj
}

func (obj *attribute) msg() *opentestbed.Attribute {
	return obj.obj
}

func (obj *attribute) setMsg(msg *opentestbed.Attribute) Attribute {

	proto.Merge(obj.obj, msg)
	return obj
}

type marshalattribute struct {
	obj *attribute
}

type marshalAttribute interface {
	// ToProto marshals Attribute to protobuf object *opentestbed.Attribute
	ToProto() (*opentestbed.Attribute, error)
	// ToPbText marshals Attribute to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Attribute to YAML text
	ToYaml() (string, error)
	// ToJson marshals Attribute to JSON text
	ToJson() (string, error)
}

type unMarshalattribute struct {
	obj *attribute
}

type unMarshalAttribute interface {
	// FromProto unmarshals Attribute from protobuf object *opentestbed.Attribute
	FromProto(msg *opentestbed.Attribute) (Attribute, error)
	// FromPbText unmarshals Attribute from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Attribute from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Attribute from JSON text
	FromJson(value string) error
}

func (obj *attribute) Marshal() marshalAttribute {
	if obj.marshaller == nil {
		obj.marshaller = &marshalattribute{obj: obj}
	}
	return obj.marshaller
}

func (obj *attribute) Unmarshal() unMarshalAttribute {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshalattribute{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshalattribute) ToProto() (*opentestbed.Attribute, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshalattribute) FromProto(msg *opentestbed.Attribute) (Attribute, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshalattribute) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshalattribute) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshalattribute) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalattribute) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshalattribute) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshalattribute) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *attribute) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *attribute) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *attribute) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *attribute) Clone() (Attribute, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewAttribute()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// Attribute is attributes of the device ports that specify an internal architecture behind the port, for example: NPU #, NPU Core, Slice #
type Attribute interface {
	Validation
	// msg marshals Attribute to protobuf object *opentestbed.Attribute
	// and doesn't set defaults
	msg() *opentestbed.Attribute
	// setMsg unmarshals Attribute from protobuf object *opentestbed.Attribute
	// and doesn't set defaults
	setMsg(*opentestbed.Attribute) Attribute
	// provides marshal interface
	Marshal() marshalAttribute
	// provides unmarshal interface
	Unmarshal() unMarshalAttribute
	// validate validates Attribute
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Attribute, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Key returns string, set in Attribute.
	Key() string
	// SetKey assigns string provided by user to Attribute
	SetKey(value string) Attribute
	// HasKey checks if Key has been set in Attribute
	HasKey() bool
	// Value returns string, set in Attribute.
	Value() string
	// SetValue assigns string provided by user to Attribute
	SetValue(value string) Attribute
	// HasValue checks if Value has been set in Attribute
	HasValue() bool
}

// Globally unique name of an object. It also serves as the primary key for arrays of objects.
// Key returns a string
func (obj *attribute) Key() string {

	return *obj.obj.Key

}

// Globally unique name of an object. It also serves as the primary key for arrays of objects.
// Key returns a string
func (obj *attribute) HasKey() bool {
	return obj.obj.Key != nil
}

// Globally unique name of an object. It also serves as the primary key for arrays of objects.
// SetKey sets the string value in the Attribute object
func (obj *attribute) SetKey(value string) Attribute {

	obj.obj.Key = &value
	return obj
}

// description is TBD
// Value returns a string
func (obj *attribute) Value() string {

	return *obj.obj.Value

}

// description is TBD
// Value returns a string
func (obj *attribute) HasValue() bool {
	return obj.obj.Value != nil
}

// description is TBD
// SetValue sets the string value in the Attribute object
func (obj *attribute) SetValue(value string) Attribute {

	obj.obj.Value = &value
	return obj
}

func (obj *attribute) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

}

func (obj *attribute) setDefault() {

}

// ***** LinkSrc *****
type linkSrc struct {
	validation
	obj          *opentestbed.LinkSrc
	marshaller   marshalLinkSrc
	unMarshaller unMarshalLinkSrc
}

func NewLinkSrc() LinkSrc {
	obj := linkSrc{obj: &opentestbed.LinkSrc{}}
	obj.setDefault()
	return &obj
}

func (obj *linkSrc) msg() *opentestbed.LinkSrc {
	return obj.obj
}

func (obj *linkSrc) setMsg(msg *opentestbed.LinkSrc) LinkSrc {

	proto.Merge(obj.obj, msg)
	return obj
}

type marshallinkSrc struct {
	obj *linkSrc
}

type marshalLinkSrc interface {
	// ToProto marshals LinkSrc to protobuf object *opentestbed.LinkSrc
	ToProto() (*opentestbed.LinkSrc, error)
	// ToPbText marshals LinkSrc to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals LinkSrc to YAML text
	ToYaml() (string, error)
	// ToJson marshals LinkSrc to JSON text
	ToJson() (string, error)
}

type unMarshallinkSrc struct {
	obj *linkSrc
}

type unMarshalLinkSrc interface {
	// FromProto unmarshals LinkSrc from protobuf object *opentestbed.LinkSrc
	FromProto(msg *opentestbed.LinkSrc) (LinkSrc, error)
	// FromPbText unmarshals LinkSrc from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals LinkSrc from YAML text
	FromYaml(value string) error
	// FromJson unmarshals LinkSrc from JSON text
	FromJson(value string) error
}

func (obj *linkSrc) Marshal() marshalLinkSrc {
	if obj.marshaller == nil {
		obj.marshaller = &marshallinkSrc{obj: obj}
	}
	return obj.marshaller
}

func (obj *linkSrc) Unmarshal() unMarshalLinkSrc {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshallinkSrc{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshallinkSrc) ToProto() (*opentestbed.LinkSrc, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshallinkSrc) FromProto(msg *opentestbed.LinkSrc) (LinkSrc, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshallinkSrc) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshallinkSrc) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshallinkSrc) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshallinkSrc) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshallinkSrc) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshallinkSrc) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *linkSrc) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *linkSrc) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *linkSrc) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *linkSrc) Clone() (LinkSrc, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewLinkSrc()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// LinkSrc is src for the link.
type LinkSrc interface {
	Validation
	// msg marshals LinkSrc to protobuf object *opentestbed.LinkSrc
	// and doesn't set defaults
	msg() *opentestbed.LinkSrc
	// setMsg unmarshals LinkSrc from protobuf object *opentestbed.LinkSrc
	// and doesn't set defaults
	setMsg(*opentestbed.LinkSrc) LinkSrc
	// provides marshal interface
	Marshal() marshalLinkSrc
	// provides unmarshal interface
	Unmarshal() unMarshalLinkSrc
	// validate validates LinkSrc
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (LinkSrc, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Device returns string, set in LinkSrc.
	Device() string
	// SetDevice assigns string provided by user to LinkSrc
	SetDevice(value string) LinkSrc
	// Port returns string, set in LinkSrc.
	Port() string
	// SetPort assigns string provided by user to LinkSrc
	SetPort(value string) LinkSrc
}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// Device returns a string
func (obj *linkSrc) Device() string {

	return *obj.obj.Device

}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// SetDevice sets the string value in the LinkSrc object
func (obj *linkSrc) SetDevice(value string) LinkSrc {

	obj.obj.Device = &value
	return obj
}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/Port/properties/id
//
// x-constraint:
// - /components/schemas/Port/properties/id
//
// Port returns a string
func (obj *linkSrc) Port() string {

	return *obj.obj.Port

}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/Port/properties/id
//
// x-constraint:
// - /components/schemas/Port/properties/id
//
// SetPort sets the string value in the LinkSrc object
func (obj *linkSrc) SetPort(value string) LinkSrc {

	obj.obj.Port = &value
	return obj
}

func (obj *linkSrc) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Device is required
	if obj.obj.Device == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Device is required field on interface LinkSrc")
	}

	// Port is required
	if obj.obj.Port == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Port is required field on interface LinkSrc")
	}
}

func (obj *linkSrc) setDefault() {

}

// ***** LinkDst *****
type linkDst struct {
	validation
	obj          *opentestbed.LinkDst
	marshaller   marshalLinkDst
	unMarshaller unMarshalLinkDst
}

func NewLinkDst() LinkDst {
	obj := linkDst{obj: &opentestbed.LinkDst{}}
	obj.setDefault()
	return &obj
}

func (obj *linkDst) msg() *opentestbed.LinkDst {
	return obj.obj
}

func (obj *linkDst) setMsg(msg *opentestbed.LinkDst) LinkDst {

	proto.Merge(obj.obj, msg)
	return obj
}

type marshallinkDst struct {
	obj *linkDst
}

type marshalLinkDst interface {
	// ToProto marshals LinkDst to protobuf object *opentestbed.LinkDst
	ToProto() (*opentestbed.LinkDst, error)
	// ToPbText marshals LinkDst to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals LinkDst to YAML text
	ToYaml() (string, error)
	// ToJson marshals LinkDst to JSON text
	ToJson() (string, error)
}

type unMarshallinkDst struct {
	obj *linkDst
}

type unMarshalLinkDst interface {
	// FromProto unmarshals LinkDst from protobuf object *opentestbed.LinkDst
	FromProto(msg *opentestbed.LinkDst) (LinkDst, error)
	// FromPbText unmarshals LinkDst from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals LinkDst from YAML text
	FromYaml(value string) error
	// FromJson unmarshals LinkDst from JSON text
	FromJson(value string) error
}

func (obj *linkDst) Marshal() marshalLinkDst {
	if obj.marshaller == nil {
		obj.marshaller = &marshallinkDst{obj: obj}
	}
	return obj.marshaller
}

func (obj *linkDst) Unmarshal() unMarshalLinkDst {
	if obj.unMarshaller == nil {
		obj.unMarshaller = &unMarshallinkDst{obj: obj}
	}
	return obj.unMarshaller
}

func (m *marshallinkDst) ToProto() (*opentestbed.LinkDst, error) {
	err := m.obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return m.obj.msg(), nil
}

func (m *unMarshallinkDst) FromProto(msg *opentestbed.LinkDst) (LinkDst, error) {
	newObj := m.obj.setMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (m *marshallinkDst) ToPbText() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (m *unMarshallinkDst) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), m.obj.msg())
	if retObj != nil {
		return retObj
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (m *marshallinkDst) ToYaml() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshallinkDst) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (m *marshallinkDst) ToJson() (string, error) {
	vErr := m.obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(m.obj.msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *unMarshallinkDst) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), m.obj.msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := m.obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *linkDst) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *linkDst) validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *linkDst) String() string {
	str, err := obj.Marshal().ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *linkDst) Clone() (LinkDst, error) {
	vErr := obj.validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewLinkDst()
	data, err := proto.Marshal(obj.msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// LinkDst is dst for the link.
type LinkDst interface {
	Validation
	// msg marshals LinkDst to protobuf object *opentestbed.LinkDst
	// and doesn't set defaults
	msg() *opentestbed.LinkDst
	// setMsg unmarshals LinkDst from protobuf object *opentestbed.LinkDst
	// and doesn't set defaults
	setMsg(*opentestbed.LinkDst) LinkDst
	// provides marshal interface
	Marshal() marshalLinkDst
	// provides unmarshal interface
	Unmarshal() unMarshalLinkDst
	// validate validates LinkDst
	validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (LinkDst, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Device returns string, set in LinkDst.
	Device() string
	// SetDevice assigns string provided by user to LinkDst
	SetDevice(value string) LinkDst
	// Port returns string, set in LinkDst.
	Port() string
	// SetPort assigns string provided by user to LinkDst
	SetPort(value string) LinkDst
}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// Device returns a string
func (obj *linkDst) Device() string {

	return *obj.obj.Device

}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// SetDevice sets the string value in the LinkDst object
func (obj *linkDst) SetDevice(value string) LinkDst {

	obj.obj.Device = &value
	return obj
}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/port/properties/id
//
// x-constraint:
// - /components/schemas/port/properties/id
//
// Port returns a string
func (obj *linkDst) Port() string {

	return *obj.obj.Port

}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/port/properties/id
//
// x-constraint:
// - /components/schemas/port/properties/id
//
// SetPort sets the string value in the LinkDst object
func (obj *linkDst) SetPort(value string) LinkDst {

	obj.obj.Port = &value
	return obj
}

func (obj *linkDst) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Device is required
	if obj.obj.Device == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Device is required field on interface LinkDst")
	}

	// Port is required
	if obj.obj.Port == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Port is required field on interface LinkDst")
	}
}

func (obj *linkDst) setDefault() {

}
